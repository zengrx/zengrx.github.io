<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/flower_128px.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/flower_32px.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/flower_16px.png?v=5.1.3">


  <link rel="mask-icon" href="/images/flower_logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Embedded Android Translation," />










<meta name="description" content="内部入门 Internals Primer正如我们之前所说，安卓源码可以自由地为人们所下载、修改以及安装至选择的机器中。实际上，仅仅是获取、编译代码，再将其运行在安卓模拟器这个过程并不值得一提。能够为你自己的硬件及设备客制化AOSP，做到这件事的前提是需要对安卓的内部结构有一定掌握。所以在这一章，我们先从一个较高的视角去看待安卓内部，在后续章节中再找机会深入理解各个部分。As we’ve just">
<meta name="keywords" content="Embedded Android Translation">
<meta property="og:type" content="article">
<meta property="og:title" content="Embedded Android -- Chapter2">
<meta property="og:url" content="http://yoursite.com/2018/11/10/Embedded-Android-Chapter2/index.html">
<meta property="og:site_name" content="二又三">
<meta property="og:description" content="内部入门 Internals Primer正如我们之前所说，安卓源码可以自由地为人们所下载、修改以及安装至选择的机器中。实际上，仅仅是获取、编译代码，再将其运行在安卓模拟器这个过程并不值得一提。能够为你自己的硬件及设备客制化AOSP，做到这件事的前提是需要对安卓的内部结构有一定掌握。所以在这一章，我们先从一个较高的视角去看待安卓内部，在后续章节中再找机会深入理解各个部分。As we’ve just">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2424151-0348fb02f2a6898b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2424151-3162cfa959ce7c50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-04-21T13:01:28.470Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Embedded Android -- Chapter2">
<meta name="twitter:description" content="内部入门 Internals Primer正如我们之前所说，安卓源码可以自由地为人们所下载、修改以及安装至选择的机器中。实际上，仅仅是获取、编译代码，再将其运行在安卓模拟器这个过程并不值得一提。能够为你自己的硬件及设备客制化AOSP，做到这件事的前提是需要对安卓的内部结构有一定掌握。所以在这一章，我们先从一个较高的视角去看待安卓内部，在后续章节中再找机会深入理解各个部分。As we’ve just">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2424151-0348fb02f2a6898b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/11/10/Embedded-Android-Chapter2/"/>





  <title>Embedded Android -- Chapter2 | 二又三</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">二又三</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">∠(ᐛ」∠)＿</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/10/Embedded-Android-Chapter2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ross Zeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/pk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="二又三">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Embedded Android -- Chapter2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-10T11:06:33+08:00">
                2018-11-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="内部入门-Internals-Primer"><a href="#内部入门-Internals-Primer" class="headerlink" title="内部入门 Internals Primer"></a>内部入门 Internals Primer</h3><p>正如我们之前所说，安卓源码可以自由地为人们所下载、修改以及安装至选择的机器中。实际上，仅仅是获取、编译代码，再将其运行在安卓模拟器这个过程并不值得一提。能够为你自己的硬件及设备客制化AOSP，做到这件事的前提是需要对安卓的内部结构有一定掌握。所以在这一章，我们先从一个较高的视角去看待安卓内部，在后续章节中再找机会深入理解各个部分。<br>As we’ve just seen, Android’s source are freely available for you to download, modify, and install for any device you choose. In fact, it is fairly trivial to just grab the code, build it, and run it in the Android emulator. To customize the AOSP to your device and its hardware, however, you’ll need to first understand Android’s internals to a certain extent. So we’ll get high-level view of Android internals in this chapters, and get opportunity in later chapters to dig into parts of internals in greater detail, including trying said internals to the actual AOSP sources.</p>
<a id="more"></a>
<h3 id="应用开发人员的看法-App-Developer’s-View"><a href="#应用开发人员的看法-App-Developer’s-View" class="headerlink" title="应用开发人员的看法 App Developer’s View"></a>应用开发人员的看法 App Developer’s View</h3><p>为安卓研发人员提供的API并不同于其他现有的API，包括Linux世界中能够找到的任何API，这值得花一些时间以应用开发人员的视角去理解“Android”到底是什么，虽然每个人研究AOSP后对安卓的理解都不一样。作为一名嵌入式工程师，你或许不需要像其他一些同事那样直接面对安卓应用的API的特性。如果没有别的，你也可以和他们共享通用的语言。当然，这部分只是一个总结，并且也建议你钻研一些应用开发的知识，从而获得更加深入的理解。<br>Given that Android’s development API is unlike any other existing API, including anything found in the Linux world, it’s important to spend some time understanding what “Android” looks like from the app developers’ perspective, even though it’s very different from what Android looks like for anyone hacking the AOSP. As an embedded developer working on embedding Android on device, you might not have to actually deal directly with the idiosyncracies of Android’s app development API, but some of your colleagues might. If nothing else, you might as well share a common linguo with app developers. Of course, this section is merely a summary, and I recommend you read up on Android app development for more in-depth coverage.</p>
<h4 id="安卓概念-Android-Concepts"><a href="#安卓概念-Android-Concepts" class="headerlink" title="安卓概念 Android Concepts"></a>安卓概念 Android Concepts</h4><p>应用开发人员在研发安卓应用时必须要掌握几个关键的概念。这些概念塑造了所有安卓应用的体系，并规范了开发人员什么能做，什么不能做。总的来说，它们把用户的生活变得更好，但有时也会遇到一些挑战。<br>Application developers must take a few key concepts into account when developing Android apps. These concepts shape the architecture of all Android apps and dictate what developers can and cannot do. Overall, they make the users’ life better, but they can sometimes be challenging to deal with.</p>
<h5 id="组件-components"><a href="#组件-components" class="headerlink" title="组件 components"></a>组件 components</h5><p>安卓应用程序由一些零散而有联系的组件构成。一个应用程序的组件可以授权使用或使用另一个应用的组件。最重要的是，这里面并没有如<strong>main()</strong>一样单一入口点之类的东西。相反，开发人员使用一个叫做<em>intent</em>的预定义事件将组件们联系在一起，从而在发生相应事件时激活它们的组件。一个简单的例子是处理用户联系人数据库的组件，当用户按下拨号器或其他程序的联系人按钮时会被激活。所以一个应用程序可以拥有与它组件相同数量的入口点。<br>Android applications are made of loosely-tied <em>components</em>. Components of one app can invoke/use components of other apps. Most importantly, there is no single entry point to an Android app: no <strong>main()</strong> function or any equivalent. Instead, there are pre-defind events called <em>intents</em> that developers can tie their components to, thereby enabling their components to be activated on the occurrence of the corresponding events. A simple example is the component that handles the user’s contacts database, which is invoked when the user presses a Contacts button in the Dialer or another app. An app therefore can have as many entry points as it has components.</p>
<p>安卓的四大组件如下：<br>There are four main types of components:</p>
<blockquote>
<p><em>活动</em> <em>Activities</em><br>正如“窗体”在基于视窗用户界面的系统中作为主要的视觉交互构建块一样，活动就是安卓应用的构建块。但不同于窗体，活动不能够被“最大化”，“最小化”或者“调整大小”。反之，活动永远占据整个视觉区域，堆叠在其他活动的顶端。并类似浏览器记录网页访问序列那样允许用户“返回”之前的地方。事实上，如之前章节所描述，所有的安卓设备都必须要有一个“BACK”键来指示用户操作行为。与浏览器不同的是，并不存在一个“前进”按钮，活动只允许“返回”。<br>Just as the “window” is the main building block of all visual interaction in window-based GUI system, acitvites are the building block in an Android app. Unlike a window, however, activities cannot be “maximized,” “minimized,” or “resized.” Instead, activities always take the entirety of the visual area and are made to be stacked up on top of each other in the same way as a browser remembers webpages in the sequence they were accessed, allowing the user to go “back” to where he was previously. In fact, as descirbed in the previous chapter, all Android devices must have a “BACK” button to mark this behavior available to the user. In contrast to web browsing, though, there is no button corresponding to the “forward” browsing action; only “back” is possible.<br>另一个全局定义是安卓意图允许活动在应用启动器（手机的应用程序列表页）上展示一个图标。因为绝大多数的应用都希望被展示在主程序列表中，它们提供了至少一个活动去响应这个意图。一般而言，使用者将从一个特定 的活动开始，再移动到另一个活动，最后创建与这些活动相关的堆栈。这些活动组成的堆栈就是<em>任务</em>。用户可以通过点击HOME按键进入应用启动界面，启动另一个活动堆栈来切换一个新的任务。<br>One globally defined Android intent allows an acitvity to be displayed as an icon on the app launcher (the main app list on a phone.) Because the vast majority of apps want to appear on the main app list, they provide at least one activity  that is defined as capable of responding to that intent. Typically, the user will start from a particular activity and move through other end up creating a stack of activities all related to the one they originally launched; this stack of activities is a <em>task</em>. The user can then switch to another task by clicking the HOME button and starting another activity stack from the app launcher.</p>
<p><em>服务</em> <em>Services</em><br>安卓中的服务有些类似于Unix系中的后台进程或守护进程。本质上，服务在其他组件有需求是被激活的，并且一般会根据调用者的需求持续一段时间。最重要的是，服务可以被提供给从程序外的组件，从而为其他应用提供一些核心功能。服务激活时通常没有用户界面。<br>Android services are akin to background processes or daemons in the Unix world. Essentially, a service is a activated when another component requires its services and typically remains active for the duration required by its caller. Most importantly, though, services can be made available to components outside an app, thereby exposing some of that app’s core functionality to other apps. There is usually no visualsign of service being active.</p>
<p><em>广播接收器</em> <em>Broadcast Receivers</em><br>广播接收器有点像中断处理程序。当一个关键事件发生时，广播接收器会被触发处理应用的行为。例如一个应用可能希望在低电或飞行模式（为了关闭无线连接）时得到通知。当不处理它们所注册的特殊事件时，广播接收器是不活动的。<br>Broadcast receivers are akin to interrupt handlers. When a key event occurs, a broadcast receiver is triggered to handle that event on the app’s behalf. For instance, an app might want to be notified when the battery level is low when “airplane mode” (to shut down the wireless connections) has been activated. When not handling a specific event for which they are registered, broadcast receivers are otherwise inactive.</p>
<p><em>内容提供者</em> <em>Content Providers</em><br>内容提供者本质上就是数据库。一般来说一个应用会在需要为其他应用提供数据访问时包含一个内容提供者。例如开发一个Twitter客户端应用，你可以通过内容提供者给设备上的其他应用程序获取推送信息。大部分的内容提供者依赖安卓中的SQLite功能，但是也可以使用用户文件或者其他类型存储。<br>Content providers are essentially databases. Usually, an app will include a content provider if it needs to make its data accessible to other apps. If you’re building a Twitter client app, for instance, you could give other apps on the device access the tweet feed you’re persenting to the user through a content provider. All content providers present the same API to apps, regardless of how they are actually implemented internally. Most content providers rely on the SQLite functionality included in Android, but they can also user files or other types of storage.</p>
</blockquote>
<h5 id="意图-Intents"><a href="#意图-Intents" class="headerlink" title="意图 Intents"></a>意图 Intents</h5><p>意图也是安卓中最为重要的概念之一。它们是允许组件间相互作用的后期绑定机制。应用开发人员可以通过发送意图的方式，让活动“浏览”一个网页或者PDF，因此即使活动本身不支持这类的能力，使用者也能够以这种形式实现。当然也有更魔幻的意图使用方式，只要开发人员想的话，可以发出一条特殊的意图拨打电话。<br>Intents are one of the most important concepts in Android. They are the late-binding mechanisms that allow components to interact. An app developer could send an intent for an activity to “view” a web page or “view” a PDF, hence making it possible for the user to view a designated HTML or PDF document even if the requesting app itself doesn’t include the capabilites to do so. More fancy use of intents is also possible. An app developer could, for instance, send a specific intent to trigger a phone call.</p>
<p>可以将意图理解为一种不用预定义或需要特殊设计的目标组件和应用的多态Unix信号。意图本身是一种被动的对象，是内容（载荷），激发其的机制会与系统规则一起引导它的行为。例如其中的一个系统规则是意图与其被发送到的组件相关。就像被发送至服务的意图就只能够被服务接收，无法被活动或者广播接收器接收。<br>Think of intents as polymorphic Unix signals that don’t necessarily have to be predefined or require a specific designated target component or app. The intent itself is a passive object. It’s contents (payload), the mechanism used to fire it along with the system’s rules that will gate its behavior. One of the system’s rules, for instance, is that intents are tied to the type of component they are sent to. An intent sent to a service, for example, can only be received by a service, not an activity or broadcast receiver.</p>
<p>组件可以通过<em>manifast</em>的过滤被声明为处理特定的意图类型。系统随后将意图与过滤器匹配，并在运行时出发相应的组件。意图也能够发送给显式的过滤器，以绕过接收组件对意图声明的需求。但是，显式调用要求应用提前知道被指定的组件，这通常仅适用于同一个应用程序中的组件发送意图的情况。<br>Components can be declared as capable of dealing with given intent types using filters in the <em>manifast</em> file. The system will thereafter match intents to that filter and trigger the corresponding component at runtime. An intent can also be sent to an explicit filter, bypassing the need to declare that intent within the receiving componnent’s filter. The explicit invocation, though, requires the app to know about the designated component ahead of time, which typically applies only when intents are sent within comonents of hte same app.</p>
<h5 id="组件的生命周期-Component-Lifecycle"><a href="#组件的生命周期-Component-Lifecycle" class="headerlink" title="组件的生命周期 Component Lifecycle"></a>组件的生命周期 Component Lifecycle</h5><p>安卓的另一个中心思想是用户不应该管理任务的切换。因此，安卓中并不会存在任务栏之类的功能。相反，用户可以随意启动应用程序，并通过点击HOME键后选择主界面上的其他应用来切换。这些被点击的应用可能是全新的，也可能是之前已经启动过的，即活动栈（也可以说任务）已经存在。<br>Another central tenant of Android is that the user should never have to manage task switching. Hence, there is no task-bar or any equivalent functionality in Android. Instead, the user is allowed to start as many apps as he wants and “switch” between apps by clicking HOME to go to the home screen and clicking on any other app. The app he clicks may be an entirely new one, or one that he previously started and for which<br>an activity stack (a.k.a. a “task”) already exists.</p>
<p>（corollary？）这种设计会导致应用程序逐渐消耗越来越多的系统资源，而这些资源不能保证操作永远继续下去。有些时候，系统会不得不回收一些最近较少使用或无优先级的组件来获取资源，留给新激活的组件使用。然而，资源回收应该对用户完全透明。换言之，当旧组件被新组件换下后，用户又回到原来的组件时，组件应该从它被换下的地方开始启动，就好像它一直在内存中等待一样。<br>The corrollary to, or consequence of, this design decision is that apps gradually use up more and more system resources as they are started, which can’t go on forever. At some point, the system will have to start reclaiming the resources of the least recently used or non-priority components in order to make way for newly-activated components. Yet still, this resource recycling should be entirely transparent to the user. In other words, when a component is taken down to make way for new one, and then the user returns to the original component, it should start up at the point where it was taken down and act as if it was waiting in memory all along.</p>
<p>为了实现这个行为，安卓定义了一个标准生命周期组件。应用程序开发人员必须通过实现一系列与生命周期相关事件触发的组件回调，从而管理组件的生命周期。例如，当一个活动不再存在于前台（因此比在前台更容易被杀），它的<strong>onPause()</strong>回调则被触发。<br>To make this behavior possible, Android defines a standard lifecycle components. An app developer must manage her components’ lifecycle by implementing a series of callbacks for each component that are triggered by events related to the component lifecycle. For instance, when an activity is no longer in the foreground (and therefore more likely to be destroyed than if it’s in the foreground), its <strong>onPause()</strong> callback is triggered.</p>
<p>处理组件回调是应用开发人员最大的挑战之一，因为在处理关键事件时他们必须要小心地保存和恢复组件状态。最理想的结果是，用户不需要在应用间切换任务或担心开启新应用后之前的应用会被杀掉。<br>Managing component lifecycles is one of the greatest challenges faced by app developers, because they must carefully save and restore component states on key transitional events. The desired end result is that the user never needs to “task switch” between apps or be aware that components from previously-used apps were destroyed to make way for new ones he started.</p>
<h5 id="Manifest文件-Manifest-File"><a href="#Manifest文件-Manifest-File" class="headerlink" title="Manifest文件 Manifest File"></a>Manifest文件 Manifest File</h5><p>如果一定要说一个应用中的“主”入口点，那么manifest文件可以算得上。基本上，它告诉了系统应用程序的组件，运行应用的要求，最小API等级以及硬件需求等等。Manifest格式像xml文件一样，以<em>AndroidManifest.xml</em>名称被保存在应用程序文件的最顶端目录中。应用的组件通常都是静态地描述在manifest中。事实上，除了广播接收器可以在运行时被动态注册，其余的组件都必须在构建时被声明在manifest文件中。<br>If there has to be a “main” entry point to an app, the manifest file is likely it. Basically, it informs the system of the app’s components, the capabilities required to run the app, the minimum level of the API required, any hardware requirements, etc. The manifest is formatted as an XML file and resides at the top-most directory of the app’s sources as <em>AndroidManifest.xml</em>. The apps’ components are typically all described statically in<br>the manifest file. In fact, apart from broadcast receivers, which can be registered at runtime, all other components must be declared at build time in the manifest file.</p>
<h5 id="进程与线程-Processses-and-Threads"><a href="#进程与线程-Processses-and-Threads" class="headerlink" title="进程与线程 Processses and Threads"></a>进程与线程 Processses and Threads</h5><p>无论应用何时被激活，是由系统还是其他应用激活，都会起一个进程来容纳该应用的组件。除非开发人员重载了系统默认方法，否则初始组件起来之后所有的应用组件都会跑在同一个进程中。换句话说，一个应用的所有组件都会运行在单一的Linux进程里。因此，开发人员需要避免在标准组件中进行耗时或阻塞操作，并将这类操作放在线程中实现。<br>Whenever an app’s component is activated, whether it be by the system or another app, a process will be started to house that app’s components. And unless the app developer does anything to overide the system defaults, all other components of that app that start after the initial component is activated will run within the same process as that component. In other words, all components of an app are comprised within a single Linux process. Hence, developers should avoid making long or blocking operations in standard components and use threads instead.</p>
<p>而且，用户基本会允许激活任意数量的组件，基本上，这几个为包含用户组件的应用程序服务的Linux进程会一直存在于系统中。当运行太多进程导致无法无法启动新进程时，Linux内核将启动OOM机制。这时，安卓内核中的OOM将被调用，并会杀掉必须结束的进程以释放空间。<br>And because the user is essentially allowed to activate as many components as he wants, several Linux processes are typically active at any time to serve the many apps containing the user’s components. When there are too many processes running to allow for new ones to start, the Linux kernel’s Out-Of-Memory (OOM) killing mechanisms will kick in. At that point, Android’s in-kernel OOM handler will get called and it will determine which processes must be killed to make space.</p>
<p>简而言之，安卓的整体行为取决于低内存情况。<br>Put simply, the entirety of Android’s behavior is predicated on low-memory conditions. </p>
<p>如果应用开发人员已经正确实现了组件的生命周期，这时应用的进程被OOM杀掉后，用户不会看到任何不良的行为。实际上，出于实际目的，用户甚至不会注意到容纳应用程序组件的进程消失，并且随后又会“自动”重新创建。<br>If the developer of the app whose process is killed by Android’s OOM handler has implemented his components’ lifecycles properly, the user should see no adverse behavior. For all practical purposes, in fact, the user should not even notice that the process housing the app’s components went away and got recreated “automagically” later.</p>
<h5 id="远程过程调用（RPC）-Remote-Proceduce-Calls-RPC"><a href="#远程过程调用（RPC）-Remote-Proceduce-Calls-RPC" class="headerlink" title="远程过程调用（RPC） Remote Proceduce Calls (RPC)"></a>远程过程调用（RPC） Remote Proceduce Calls (RPC)</h5><p>与系统中许多其他组件一样，安卓定义了它自己的RPC/IPC（IPC-进程间通信）机制：Binder。所以跨组件通信不是使用典型的系统IPC或套接字实现，而是通过访问/dev/binder的方式使用内核Binder机制，这部分会在本章稍后部分介绍。<br>Much like many other components of the system, Android defines its own RPC/IPC mechanism: Binder. So communication across components is not done using the typical System V IPC or sockets. Instead, components use the in-kernel Binder mechanism, accessible through /dev/binder, which will be covered later in this chapter.</p>
<p>应用开发人员并不会直接使用Binder机制，相反，他们必须使用安卓的接口描述语言（IDL）。接口描述通常保存在一个.aidl文件中，由aidl工具处理生成适当的存根，使用binder机制传输数据，以及在传输对象的要求下编组和解编代码。<br>App developers, however, do not use the Binder mechanism directly. Instead, they must define and interact with interfaces using Android’s Interface Definition Language (IDL). Interface definitions are usually stored in an .aidl file and are processed by the aidl tool to generate the proper stubs and marshalling/unmarshalling code required to transfer objects and data back and forth using the Binder mechanism.</p>
<h4 id="框架介绍-Framework-Intro"><a href="#框架介绍-Framework-Intro" class="headerlink" title="框架介绍 Framework Intro"></a>框架介绍 Framework Intro</h4><p>除了之前讨论的概念之外，安卓还定义了自己的开发框架，它允许开发人员在其他开发框架中访问基本功能。我们来看一看这个框架以及它的能力。<br>In addition to the concepts we just discussed, Android also defines its own development framework, which allows developers to access functionality typically found in other development frameworks. Let’s take a brief look at this framework and its capabilities.</p>
<p><em>用户接口</em> <em>User Interface</em></p>
<p>安卓的UI元素包含了如按钮，文本框，对话框，菜单和事件处理这些传统控件。如果开发人员使用过其他UI框架，那么接触这部分接口相对简单。<br>UI elements in Android include traditional widgets such as buttons, text boxes, dialogs, menus, and event handlers. This part of the API is relatively straight-forward and developers usually find their way around it fairly easily if they’ve already coded for any other UI framework.</p>
<p>安卓中所有的UI对象都是继承于<strong>View</strong>类，并组织在<strong>ViewGroup</strong>的层次结构中。一个活动的UI可以静态地在XML（也是最常用的方法）中定义，也可以在java中动态声明。如果需要的话，也可以在运行时由java修改。一个活动的UI会在其处于<strong>ViewGroup</strong>顶部时才会显示。<br>All UI objects in Android are built as descendants of the <strong>View</strong> class and are organized within a hierarchy of <strong>ViewGroup</strong>s. An activity’s UI can actually be specified either statically in XML (which is the usual way) or declared dynamically in Java. The UI can also be modified at runtime in Java if need be. An activity’s UI is displayed when its content is set as the root of a <strong>ViewGroup</strong> hierarchy.</p>
<p><em>数据存储</em> <em>Data Storage</em></p>
<p>安卓为开发人员提供了多种数据存储选项。对于简单的存储需求，安卓提供了shared preferences，允许将密钥对值保存在所有组件共享的组件或特定的单独文件中。开发者也可以直接操作这些文件，文件由应用程序私下存储，所以其他程序可能无法读写。应用开发人员也可以使用安卓中的SQLite管理自己的私有数据库。其他应用可以通过内容提供者组件来访问这些数据库。<br>Android presents developers with several storage options. For simple storage needs, Android provides shared preferences, which allows developers to store keypair values either in a data-set shared by all components of the app or within a specific separate file. Developers can also manipulate files directly. These files may be stored privately by the app, and therefore inaccessible to other apps, or made readable and/or writeable by other apps. App developers can also use the SQLite functionality included in Android to manage their own private database. Such a database can then be made available to other apps by hosting it within a content provider component.</p>
<p><em>安全和权限</em> <em>Security and Permissions</em></p>
<p>安卓的安全是在进程级别的。换言之，安卓依赖Linux现有的进程隔离机制来实现自己的策略。为此，每个应用安装后都会获得自己的UID个GID。本质上就像每个应用都是系统中单独的用户一样。在多任务的Unix系统中，如果没有明确的权限授权，“用户”们不能够访问彼此的资源。实际上，每个应用都运行在独立的沙盒中。<br>Security in Android is enforced at the process level. In other words, Android relies on Linux’s existing process isolation mechanisms to implement its own policies. To that end, every app installed gets its own UID and GID. Essentially, it’s as if every app is a separate “user” in the system. And as in any multi-user Unix system, these “users” cannot access each others’ resources unless permissions are explicitely granted to do so. In effect, each app lives in its own separate sandbox.</p>
<p>要离开沙盒并访问关键的系统功能或资源，应用必须要使用安卓权限机制。这就需要开发人员在manifest文件中静态地声明应用所需的权限。如访问互联网（即使用套接字）、拨打电话或使用摄像头都需要由安卓去预先定义。其他权限可由开发者声明，为其他应用与指定应用之间的组件交互。当应用安装之后，提示用户批准应用程序所需的权限。<br>To exit the sandbox and access key system functionality or resources, apps must use Android’s permission mechanisms, which require developers to statically declare the permissions needed by an app in its manifest file. Some permissions, such as the right to access the Internet (i.e. use sockets), dial the phone, or use the camera, are predefined by Android. Other permissions can be declared by app developers and then be required for other apps to interact with a given app’s components. When an app is installed, the user is prompted to approve the permissions required to run an app.</p>
<p>Access enforcement is based on per-process operations and requests to access a specific URI, and the decision to grant access to a specific functionality or resource is based on certificates and user prompts. The certificates are the ones used by app developers to sign the apps they make available on the Android Market. Hence, developers can restrict access to their apps’ functionality to other apps they themselves created in the past.</p>
<p>安卓开发框架提供了更多功能，当然不是这小节内容涵盖得了的。这部分内容可以阅读其他安卓应用开发的相关信息，或者访问<a href="developer.android.com">developer.android.com</a>获取更多关于2D、3D图像，多媒体，定位及地图，蓝牙，NFC等内容。<br>The Android development framework provides a lot more functionality, of course, than can be covered here. I invite you to read up on Android app development elsewhere or visit <a href="developer.android.com">developer.android.com</a> for more information on 2D and 3D graphics, multi-media, location and maps, Bluetooth, NFC, etc.</p>
<h4 id="应用开发工具-App-Development-Tools"><a href="#应用开发工具-App-Development-Tools" class="headerlink" title="应用开发工具 App Development Tools"></a>应用开发工具 App Development Tools</h4><p>这段我不想翻了<br>The typical way to develop Android applications is to use the freely available Android Software Development Kit (SDK). This SDK, along with Eclipse, its corresponding Android Development Tools (ADT) pulgin, and the QEMU-based emulator in the SDK, allow developers to do the vast majority of development work straight from their workstation. Developers will also usually want to test their app on real devices prior to making it availbale on the Android Market, as there usually are runtime behavior differences between the emulator and actual devices. Some software publishers take this to the extreme and test their apps on several dozens of devices before shipping a new release.</p>
<p>就算你不想为你的嵌入式系统开发任何应用，还是强烈建议你在工作站上搭建应用开发环境。这也方便编写测试应用验证AOSP修改的影响。如果计划扩展AOSP的API并且创建和发布自己的SDK，这也是必不可少的。<br>Even if you aren’t going to plan to develop any apps for your embedded system, I highly suggest you set up the development environmnet used by app developers on you  workstation. If nothing else, this will allow you to validate the effects of modifications you make to the AOSP using basic test applications. It will also be essential if you plan on extending the AOSP’s API and therefore create and distribute your own cusion SDK.</p>
<p>搭建应用开发环境可以参考之前网站中谷歌给出的手册，顺便推销一下自己的另一本书。<br>To set up an app development environment, follow the instructions provided by Google at the developer kit site just mentioned, or have a look at the book <em>Learning Andriod</em> (O’Reilly).</p>
<h4 id="原生开发-Native-Development"><a href="#原生开发-Native-Development" class="headerlink" title="原生开发 Native Development"></a>原生开发 Native Development</h4><p>事实上，绝大部分的应用都是在我们刚才讨论的环境中使用java所开发的，有的开发者也需要运行原生的C代码。为此，谷歌提供了原生开发工具包（NDK）。正如宣传的那样，这主要是为了让游戏开发者们挤出设备最后一丝性能。因此，NDK中的API主要提供图形渲染以及传感器方面的功能。例如极为出名的游戏——愤怒的小鸟，就非常依赖原生代码。<br>While the majority of apps are developed exclusively in Java using the development environment we just discussed, certain developers need to run some C code natively. To this end, Google has made the Native Development Kit (NDK) available to developers. As advertized, this is mostly aimed at game developers needing to squeeze every last possible bit of performance out of the device their game is running on. And as such, the APIs made available within the context of the NDK are mostly geared towards graphics rendering and sensor input retrieval. The infamous Angry Birds game, for example, relies heavily on code running natively.</p>
<p>另一个可能用到NDK的情景是将现有的代码库移植到安卓上。如果你手上是开发了多年的古老C代码（对于开发了其他移动应用的工作室来说十分常见），并不希望把这些东西再用java重写一遍。相反，你可以使用NDK编译之后打包到java代码中，并通过SDK的方式提供给安卓使用。例如安卓上的火狐浏览器，就非常依赖NDK去运行那部分历史代码。<br>Another possible use of the NDK is obviously to port over an existing codebase to Android. If you’ve developed a lot of legacy C code over several years (a common situation for development houses that have created applications for other mobile devices), you won’t necessarily want to rewrite it in Java. Instead, you can use the NDK to compile it for Android and package it with some Java code to use some of the more Android-specific functionality made available by the SDK. The Firefox browser, for instance, relies heavily on the NDK to run some of its legacy code on Android.</p>
<p>使用NDK的好处是可以通过SDK的形式将java代码与C代码结合使用。也正如刚才暗示的，NDK能够提供的仅仅是安卓API中有限的子集。比如你无法在NDK编译的C代码中发出一个意图，必须由java编写的SDK来做这件事情。需要提醒的是，NDK提供的API主要面向游戏开发人员。<br>As I just hinted, the nice thing about the NDK is that you can combine it with the SDK and therefore have part of your app in Java and parts of your app in C. That said, it’s crucial to understand that the NDK gives you access only to a very limited subset of the Android API. There is, for instance, no way to presently send an intent from within C code compiled with the NDK; the SDK must be used to do it in Java instead. Again, the APIs made available through the NDK are mostly geared towards game development.</p>
<p>有时嵌入式及系统开发人员希望通过NDK在安卓上完成一些平台级的工作。NDK中的“原生”一词或许在这里有一些误导，因为使用NDK时还需涉及到刚才所说对开发人员的限制和要求。所以对嵌入式开发者而言，请记住，NDK为应用开发人员在java中调用C代码提供了极大的帮助。除此之外，NDK对你所承担的工作类型几乎毫无用处。<br>Sometimes embedded and system developers coming to Android expect to be able to use the NDK to do platform-level work. The word “native” in the NDK can be misleading in that regard, because the use of the NDK still involves all of the limitations and requirements that I’ve said to apply to Java app developers. So, as an embedded developer, remember that the NDK is useful for app developers to run C code that they can call from their Java code. Apart from that, the NDK will be of little to no use for the type of work you are likely to undertake.</p>
<h3 id="总体结构-Overall-Architecture"><a href="#总体结构-Overall-Architecture" class="headerlink" title="总体结构 Overall Architecture"></a>总体结构 Overall Architecture</h3><p><img src="https://upload-images.jianshu.io/upload_images/2424151-0348fb02f2a6898b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 2-1. 安卓系统架构"></p>
<p>图2-1可能会是本书中最重要的一张图表，建议你想办法在这里放个书签，因为我们会经常应用这张图片。尽管这是个简化的视图，当然我们有机会去丰富它，但它为安卓各个部分如何搭配在一起，以及总体结构提供了一个很好的概念。<br>Figure 2-1 is probably one of the most important diagrams presented in this book, and I suggest you find a way to bookmark its location as we will often refer back to it, if not explicitly then implicitely. Although it’s a simplified view—and we will get the chance to enrich it as we go—it gives a pretty good idea of Android’s architecture and how the various bits and pieces fit together.</p>
<p>如果你熟悉Linux开发，第一件让你震惊的事情应该是，除了Linux内核本身，这一部分几乎没有什么Linux/Unix世界中常见的东西。没有glibc，没有X Window系统，没有GTK也没有BusyBox。很多Linux和嵌入式Linux老鸟确实感到安卓比较陌生。尽管安卓还是从完全干净的状态开始跑用户空间，我们会讨论如何将“遗留”或“经典”Linux应用和效应与安卓堆栈共存。<br>If you are familiar with some form of Linux development, the first thing that should strike you is that beyond the Linux kernel itself, there is little in that stack that resembles anything typically seen in the Linux or Unix world. There is no glibc, no X Window System, no GTK, no BusyBox, and so on. Many veteran Linux and embedded Linux practitioners have indeed noted that Android feels very alien. Though the Android stack starts from a clean slate with regards to user-space, we will discuss how to get “legacy” or “classic” Linux applications and utilities to coexist side-by-side with the Android stack.</p>
<p>让我们深入到安卓架构的每个部分，从图2-1底部开始往上研究，一旦完成了对各个组件的处理，我们将通过总览系统启动过程来结束这一章节。<br>Let’s take a deeper look into each part of Android’s architecture, starting from the bottom of Figure 2-1 and going up. Once we are done covering the various components, we’ll end this chapter by going over the system’s startup process.</p>
<h3 id="Linux内核-Linux-Kernel"><a href="#Linux内核-Linux-Kernel" class="headerlink" title="Linux内核 Linux Kernel"></a>Linux内核 Linux Kernel</h3><p>Linux内核是所有传统上标记为Linux发行版的中心部分，包含了如Ubuntu、Fedora、Debian这些主流发行版。虽然linux内核归档在香草版本中提供，但大多数发行版在发布给用户之前都打上自己的补丁去修复漏洞，或是提高性能。安卓也一样，开发人员们也修复了内核来满足他们的需求。<br>The Linux kernel is the center-piece of all distributions traditionally labeled as “Linux,” including mainstream distributions such as Ubuntu, Fedora, and Debian. And while it’s available in “vanilla” form from the Linux Kernel Archives, most distributions apply their own patches to it to fix bugs and enhance the performance or customize the behavior of certain aspects of it before distributing it to their users. Android, as such, is no different in that the Android developers patch the “vanilla” kernel to meed their needs.</p>
<p>然而，安卓并不按常规操作，能够在内核中找到一些与“香草”明显不同的自定义功能。事实上，linux发行版中的内核可以很容易地被kernel.org中的内核替换，并对发行版中其他的组件几乎没有影响，而安卓的用户空间组件只有在“安卓化”的内核中才能够运行。在之前的章节中也有提及，总的来说，安卓的内核是主线上的分支。<br>Android differs from standard practice, however, in relying on several custom functionalities that are significantly different from what is found in the “vanilla” kernel. In fact, whereas the kernel shipped by a Linux distribution can easily be replaced by a kernel from kernel.org with little to no impact to the rest of the distribution’s components, Android’s user-space components will simply not work unless they’re running on an “Androidized” kernel. As I had mentioned in the previous chapter, Android kenels are, in sum, forks from the mainline kernel.</p>
<p>讨论Linux内核已经超出了本书的范围，但是我们还是看一看这些“安卓主义者”向内核中添加了哪些东西。你可以通过Robert Love的linux内核开发（第三版），以及订阅linux周报（LWN）来了解内核的内部信息。LWN包含了几篇关于内核结构的重要文章，并且提供了linux内核开发的最新信息。<br>Although it’s beyond the scope of this book to discuss the Linux kernel’s internals, let’s go over the main “Androidisms” added to the kernel. You can get information about the kernel’s internals by having a look at Robert Love’s Linux Kernel Development, 3rd ed. and starting to follow the Linux Weekly News (LWN) site. LWN contains several seminal articles on the kernel’s internals and provides the latest news regarding the Linux kernel’s development.</p>
<p>请注意下面的小节只包含了最重要的部分，安卓化的内核通常在标准内核基础上打了上百个补丁，用于提供特定设备功能，修复以及增强。可以使用git在<a href="http://android.git.kernel.org中对安卓内核与主线内核进行详尽分析。另外，如PEME驱动程序是某些安卓内核的特定功能，不一定会在所有的安卓设备中使用。" target="_blank" rel="noopener">http://android.git.kernel.org中对安卓内核与主线内核进行详尽分析。另外，如PEME驱动程序是某些安卓内核的特定功能，不一定会在所有的安卓设备中使用。</a><br>Note that the following subsections cover only the most important Androidisms. Android-ified kernels typical contain several hundred patches over the standard kernel, often to provide device-specific functionality, fixes and enhancements. You can use git to do an exhaustive analysis on the commit deltas between one of the kernels at <a href="http://android.git.kernel.org" target="_blank" rel="noopener">http://android.git.kernel.org</a> and the mainline kernel they were forked from. Also, note that some of the functionality that appears in some Android-ified kernels, such as the PMEM driver for instance, is device-specific and isn’t necessarily used in all Android devices.</p>
<h4 id="Wakelocks-唤醒锁"><a href="#Wakelocks-唤醒锁" class="headerlink" title="Wakelocks 唤醒锁"></a>Wakelocks 唤醒锁</h4><p>在所有安卓主义中，这或许是最具争议的。将这个功能包含进主线内核讨论了将近2000封邮件，但仍然没有明确的路径去合并唤醒锁功能。<br>Of all the Androidisms, this is likely the most contentious. The discussion threads covering its inclusion into the mainline kernel generated close to 2,000 emails and yet still, there’s no clear path for merging the wakelock functionality.</p>
<p>理解唤醒锁是什么、能做什么，我们必须先讨论linux中的电源管理。最常见的就是笔记本电脑，当运行linux的笔记本电脑盖子合上时，操作系统通常会进入“暂停”或“休眠”模式。在这种模式下，操作系统的运行状态被保存在RAM中，其他的硬件功能都被关闭。因此，电脑可以尽可能少地使用电池。当盖子打开时，笔记本电脑就会“醒来”，用户几乎可以立即开始使用。<br>To understand what wakelocks are and do, we must first discuss how power management is typically used in Linux. The most common use case of Linux’s power management is a laptop computer. When the lid is closed on a laptop running Linux, it will usually go into “suspend” or “sleep” mode. In that mode, the system’s state is preserved in RAM but all other parts of the hardware are shut down. Hence, the computer uses as little battery power as possible. When the lid is raised, the laptop “wakes up” and the user can resume using it almost instantaneously.</p>
<p>这种操作方式在笔记本电脑和桌面设备上应用相当出色，但是并不适合如手机这样的移动设备。因此，安卓团队设计了一个机制，稍稍改变了一下规则使得其更加适合移动设备场景。安卓化的内核并不是让系统按照用户命令去休眠，而是尽可能快地休眠。只是在重要进程执行或应用程序等待用户输入时防止系统进入休眠。唤醒锁就是用来保持系统的唤醒状态。<br>That modus operandi works fine for a laptop and desktop-like devices, but it doesn’t fit mobile devices such as handsets as well. Hence, Android’s development team devised a mechanism that changes the rules slightly to make them more palatable to such use cases. Instead of letting the system be put to sleep at the user’s behest, an Androidized kernel is made to go to sleep as soon and as often as possible. And to keep the system from going to sleep while important processing is being done or while an app is waiting for the user’s input, wakelocks are provided to… keep the system awake.</p>
<p>唤醒锁和提前休眠功能构建在linux现有的电源管理机制之上。然而，他们引入了完全不同的开发模式。因为应用程序和驱动开发人员必须在用户进行关进操作或输入时抓住唤醒锁。通常，应用程序开发者不需要直接处理唤醒锁，因为他们抽象出的相关操作会自动处理锁定事件。当然，他们也可以直接向电源管理服务申请唤醒锁。另一方面，驱动开发者可以调添加到内核中的唤醒锁原语去申请和释放唤醒锁。而在驱动中使用唤醒锁的缺点就是不能够将这个驱动推到主线内核中，因为主线内核不支持唤醒锁。<br>The wakelocks and early suspend functionality are actually built on top of Linux’s existing power management functionality. However, they introduce a different development model, since application and driver developers must explicitely grab wakelocks whenever they conduct critical operations or must wait for user input. Usually, app developers don’t need to deal with wakelocks directly, because the abstractions they use automatically take care of the required locking. They can, nonetheless, communicate with the Power Manager Service if they require explicit wakelocks. Driver developers, on the other hand, can call on the added in-kernel wakelock primitives to grab and release wakelocks. The downside of using wakelocks in a driver,  however, is that it becomes impossible to push that driver into the mainline kernel, because the mainline doesn’t include wakelock support.</p>
<h4 id="Low-Memeory-Killer-低内存杀手"><a href="#Low-Memeory-Killer-低内存杀手" class="headerlink" title="Low Memeory Killer 低内存杀手"></a>Low Memeory Killer 低内存杀手</h4><p>如之前所提及的，安卓行为很大程度上取决于低内存条件。因此，OOM的行为是至关重要的。所以安卓研发团队在内核OOM杀进程之前添加了一个额外的低内存杀手。安卓的低内存杀手按照应用程序开发文档中描述的策略，淘汰了那些长时间未使用且优先级不高的组件进程。<br>As I mentioned earlier, Android’s behavior is very much predicated on low-memory conditions. Hence, out-of-memory behavior is crucial. For this reason, the Android development team has added an additional low memory killer to the kernel that kicks in before the default kernel OOM killer. Android’s low-memory killer applies the policies described in the app development documentation, weeding out processes hosting components that haven’t been used in a long time and that are not high-priority.</p>
<p>LMK基于linux中OOM调节机制，可以支持对不同进程采用不同OOM杀手优先级。基本上，OOM调度允许用户空间控制一部分内核OOM杀除策略。OOM调整范围在-17到15之间，数字越高意味着在系统内存不足时，关联进程更容易被杀掉。<br>This low memory killer is based on the OOM adjustments mechanism availalble in Linux that enables the enforcement of different OOM kill priorities for different processes. Basically, the OOM adjustments allow user space to control part of the kernel’s OOM killing policies. The OOM adjustments range from -17 to 15, with a higher number meaning the associated process is a better candidate for being killed if the system is out of memory.</p>
<p>因此安卓将不同的OOM等级做了调整，根据运行的组件归纳到不同类型的进程上，并按照进程类型给自己的LMK配置不同的阈值。这让安卓的策略有效取代了内核的OOM killer，使用达到阈值的方式踢掉进程，而不是等到系统内存用尽时再开始处理。<br>Android therefore attributes different OOM adjustment levels to different types of processes according to the components they are running, and configures its own low memory killer to apply different thresholds for each category of process. This effectively allows it to preempt the activation of the kernel’s own OOM killer—which only kicks in when the system has no memory left—by kicking in when the given thresholds are reached, not when the system runs out of memory.</p>
<p>用户空间是初始化阶段被init进程启动（见47页init章节），并在运行时由活动管理服务重新适配及局部加强，这也是系统服务的重要部分之一，负责执行先前介绍的组件生命周期以及其他许多工作。<br>The user-space policies are themselves applied by the init process at startup (see “Init” on page 47), and readjusted and partly enforced at runtime by the Activity Manager Service, which is part of the System Server. The Activity Manager is one of the most important services in the System Server and is responsible, amongst many other things, for carrying out the component lifecycle presented earlier.</p>
<h4 id="Binder-Binder"><a href="#Binder-Binder" class="headerlink" title="Binder Binder"></a>Binder Binder</h4><p>Binder是一种类似Windows下RPC/IPC的机制。它的起源最早可以追溯到Be被Palm收购之前的BeOS中。它在Palm继续开发，并作为Open-Biner项目被发布。尽管Open-Biner并没有作为一个独立的项目存活下来，但是像Dianne Hackborn和Arve Hjonnevag这些核心开发者，最终加入了安卓开发团队。<br>Binder is an RPC/IPC mechanism akin to COM under Windows. Its roots actually date back to work done within BeOS prior to Be’s assets being bought by Palm. It continued life within Plam and the fruits of that work were eventually released as the Open-Binder project. Though OpenBinder never survived as a stand-alone project, a few key developers who had worked on it, such as Dianne Hackborn and Arve Hjonnevag, eventually ended up working within the Android development team.</p>
<p>安卓的Binder机制受到了先前工作的启发，但是安卓的实现并不是直接从OpenBinder代码中直接提取，相反，它重写了OpenBinder的功能子集。如果想了解这个机制的基础及其设计理念，那么OpenBiner的文档还是必读的。<br>Android’s Binder mechanism is therefore inspired by that previous work, but Android’s implementation does not derive from the OpenBinder code. Instead, it’s a clean room rewrite of a subset of the OpenBinder functionality. The OpenBinder Documentation remains a must-read if you want to understand the mechanism’s underpinings and its design philosophy.</p>
<p>本质上，Binder试图在经典操作系统之上提供远程对象调用功能。换言之，Binder是去“尝试接受并超越经典操作系统”，而不是重新设计它们。因此，开发者们只需要面对远程服务这个对象，而不是去面对一个全新的操作系统。那么通过添加远程可调用对象扩展系统功能就比实现新的守护进程更加容易，非常符合UNIX哲学。远程对象可以用任何所需的语言实现，并可以与其他远程服务共享相同的进程空间，或是拥有自己的独立进程。使用时只需要定义接口及引用方法即可。<br>In essence, Binder attempts to provide remote object invocation capabilities on top of a classic OS. In other words, instead of re-engineering traditional OS concepts, Binder “attempts to embrace and transcend them.” Hence, developers get the benefits of dealing with remote services as objects without having to deal with a new OS. It therefore becomes very easy to extend a system’s functionality by adding remotely-invocable objects instead of implementing new daemons for providing new services, as would usually be the case in the Unix philosophy. The remote object can therefore be implemented in any desired language and may share the same process space as other remote services or have its own separate process. All that is needed to invoke its methods is its interface definition and a reference to it.</p>
<p>正如在图2-1所示，Binder是安卓架构的一个组成部分。它允许应用程序与系统服务及其他服务组件对话。不过，如之前提到的，应用开发人员并不会直接与Binder对话，相反，他们使用aidl工具生成的接口与stubs。就算程序与系统服务对接，安卓API也会将这些服务抽象，开发人员不会直接看到Binder的实际调用。<br>And as you can see in Figure 2-1, Binder is a conerstone of Android’s architecture. It’s what allows apps to talk the System Server and it’s what apps use to talk to each others’ service components, although, as I mentioned earlier, app developers don’t actually talk to the Binder directly. Instead, they use the interfaces and stubs generated by the aidl tool. Even when apps interface with the System Server, the android.* APIs abstract its services and the developer never actually sees that Binder is being used.</p>
<p>Binder机制的内核驱动是一个可通过/dev/binder访问的字符驱动程序。它使用ioctl()方法在通讯双方间传递数据包。它也允许一个进程将自己定义为“上下文管理器”。上下文管理器的重要性以及Binder驱动的实际用户空间使用将会在本章稍后部分详细讨论。<br>The in-kernel driver part of the Binder mechanism is a character driver accessible through /dev/binder. It’s used to transmit parcels of data in between the communicating parties using calls to ioctl() . It also allows one process to designate itself as the “Context Manager.” The importance of the Context Manager along with the actual userspace use of the Binder driver will be discussed in more detail later in this chapter.</p>
<h4 id="匿名共享内存-Anonymous-Share-Memory-ashmem"><a href="#匿名共享内存-Anonymous-Share-Memory-ashmem" class="headerlink" title="匿名共享内存 Anonymous Share Memory (ashmem)"></a>匿名共享内存 Anonymous Share Memory (ashmem)</h4><p>另一个在大多数操作系统中使用到的IPC机制就是共享内存。在Linux中，这一般由System V IPC机制中的POSIX SHM功能提供。如果你看过AOSP中的<em>ndk/docs/system/libc/SYSV-IPC.html</em>文件，你会发现安卓开发团队似乎并不喜欢SysV IPC。实际上，文件中的一个论点是，在Linux中使用SysV IPC机制可以导致内核资源泄漏，继而让恶意软件或行为不当的软件跑挂系统。<br>Another IPC mechanism available in most OSes is shared memory. In Linux, this is usually provided by the POSIX SHM functionality, part the System V IPC mechanisms. If you look at the <em>ndk/docs/system/libc/SYSV-IPC.html</em> file included in the AOSP, however, you’ll discover that the Android development team seems to have a dislike for SysV IPC. Indeed, the argument is made in that file that the use of SysV IPC mechanisms in Linux can lead to resource leakage within the kernel. opening the door in turn for malicious or misbehaving software to cripple the system.</p>
<p>虽然并没有任何安卓开发人员或ashmem代码或者文档中这样声明，ashmem很可能将其存在的愿意归功于安卓团队看到了SysV IPC的缺点。所以ashmem被描述为与POSIX SHM相似“但有着不同的行为。”例如当所有进程退出时，它会引入内存销毁区域计数，并在系统需要内存时收缩映射区域。它还启用了内存压力，“去掉”一个区域允许它被收缩，而“固定”则不允许被收缩。<br>Though it isn’t stated as such by Android developers or any of the documentation within the ashmem code or surrounding its use, ashmem very likely owes part of its existence to SysV IPC’s shortcomings as seen by the Android development team. Ashmem is therefore described as being similar to POSIX SHM “but with different behavior.” For instance, it does reference counting to destory memory regions when all processes referring to them have exited and will shrink mapped regions if the system is in need of memory. It will also enable memory pressure. “Unpinning” a region allows it to be shrunk, wheras “pinning” a region disallows the shrinking.</p>
<p>通常，第一个进程通过ashmem创建一个共享内存区域，并使用Binder与其他愿意共享区域的进程分享相应的文件描述符。例如Dalvik的JIT代码缓存通过ashmem为Dalvik提供实例。有许多系统服务组件，如Surface Flinger和Audio Finger也都依赖ashmem，尽管通过IMemory接口而不直接使用ashmem。<br>Typically, a first process creates a shared memory region using ashmem and uses Binder to share the corresponding file descriptor with other processes with which it wishes to share the region. Dalvik’s JIT code cache, for instance, is provided to Dalvik instances through ashmem. A lot of System Server components, such as the Surface Flinger and the Audio Flinger, rely on ashmem, though not directly but through the IMemory§ interface.</p>
<p>~§IMemory是一个仅在AOSP中可用的内部接口，不提供给应用发开人员。给app使用的最接近的类是MemoryFile。~</p>
<h4 id="闹钟-Alarm"><a href="#闹钟-Alarm" class="headerlink" title="闹钟 Alarm"></a>闹钟 Alarm</h4><p>将闹钟驱动加入内核则是另一种情况，默认的内核功能并不完全满足安卓的需求。安卓的闹钟驱动实际上在内核已有的实时时钟（RTC）与高精度计时器（HRT）的上层。内核的RTC功能为驱动开发人员提供了一个框架，用于实现定制的板级RTC功能，而内核通过主RTC驱动提供了一个独立与硬件的接口。另一方面，也允许调用者在特定的时间点被唤醒。<br>The alarm driver added to the kernel is another case where the default kernel functionality wasn’t sufficient for Android’s requirements. Android’s alarm driver is actually layered on top of the kernel’s existing Real-Time Clock (RTC) and High-Resolution Timers (HRT) functionalities. The kernel’s RTC functionality provides a framework for driver developers to create board-specific RTC functions, while the kernel exposes a single hardware-independent interface through the main RTC driver. The kenel HRT functionality, on the other hand, allows callers to get woken up at very specific points in time.</p>
<p>在香草内核中，应用开发人员通常会调用<strong>setitimer()</strong>系统方法来获取一个超时信号。系统调用允许几类计时器，其中一种是<strong>ITIMER_REAL</strong>，使用了 内核高精度计时器（HRT），但是不能在系统被挂起时使用。换言之，如果应用使用<strong>setitimer()</strong>在给定的时间后请求被唤醒，在此期间设备被挂起，应用只会在设备被唤醒时才能收到信号。<br>In “vanilla” Linux, application developers typically call the <strong>setitimer()</strong> system call to get a signal when a given time value expires. The system call allows for a handful of types of timers, one of which, <strong>ITIMER_REAL</strong>, uses the kernel’s High-Resolution Timer (HRT). This functionality, however, doesn’t work the system is suspended. In other words, if an application uses <strong>setitimer()</strong> to request being woken up at a given time and then, in the interim, the device is suspended, that application will get its signal only when the device is woken up again.</p>
<p>除了<strong>setitimer()</strong>系统调用，内核RTC驱动可以通过<em>/dev/rtc</em>访问，并允许用户使用<strong>ioctl()</strong>方法，设置一个闹钟将被系统的RTC硬件设备激活。无论系统是否被挂起，这个闹钟都会触发。因为它基于行为或RTC设备，即使系统其他部分被挂起，它依旧可以保持活动状态。<br>Separately from the <strong>setitimer()</strong> system call, the kernel’s RTC driver is accessiable through <em>/dev/rtc</em> and enables its users to use an <strong>ioctl()</strong>, among other things, to set an alarm that will be activated by the RTC hardware device in the system. That alarm will fire off whether the system is suspended or not, since it’s predicated on the behavior or the RTC device, which remains active even the rest of the system is suspended.</p>
<p>安卓的闹钟驱动聪明地结合了最好的部分。驱动默认使用内核的高精度计时器为用户提供闹钟，就像构建在内核的计时器功能。如果系统被挂起，就会调用RTC让系统在指定时间被唤醒。因此，用户空间的应用无论在何时需要一个特定的闹钟，只需要让安卓的闹钟驱动在指定时间唤醒，无需关注系统是否是挂起的。<br>Android’s alarm driver cleverly combines the best of both worlds. By default, the driver uses the kernel’s High-Reslution Timer (HRT) functionality to provide alarms to its users, much like the kernel’s own built-in timer functionality. However, if the system is about to suspend itself, it programs the RTC so that the system gets woken up at the appropriate time, Hence, whenever an application from user space needs a specific alarm, it just needs to use Android’s alarm driver to be woken up at the appropriate time, regardless of whether the system is suspended in the interim.</p>
<p>在用户空间，闹钟驱动以<em>/dev/alarm</em>的字符设备体现，允许使用者通过<strong>ioctl()</strong>设置闹钟并调整系统时间。有几个关键的AOSP组件依赖<em>/dev/alarm</em>。如Toolbox和<strong>SystemClock</strong>类，能够通过应用接口获取或设置系统时间。更为重要的是，作为系统服务的一部分，应用开发人员调用的<strong>AlarmManager</strong>类，就是闹钟管理服务通过这种方法为应用提供了闹钟服务。<br>From user-space, the alarm driver appears as the <em>/dev/alarm</em> character device and allows its users to set up alarms and adjust the system’s time (wall time) through <strong>ioctl()</strong> calls. There are a few key AOSP components that rely on <em>/dev/alarm</em>. For instance, Toolbox and the <strong>SystemClock</strong> class, available through the app development API, rely on it to set/get the system’s time. Most importantly, though, the Alarm Manager service part of the System Server uses it to provide alarm services to apps that are exposed to app developers through the <strong>AlarmManager</strong> class.</p>
<p>无论驱动还是闹钟管理都使用唤醒锁机制来保持闹钟和其他安卓唤醒锁相关行为之间的一致性。因此，当闹钟触发时，这个消费者应用程序有机会在系统下一次挂起前做任何操作，如果有必要的话。<br>Both the driver and Alarm Manager use the wakelock mechanism wherever appropriate to maintain consistency between alarms and the rest of Android’s wakelock-related behavior. Hence, when an alarm is fired, its consuming app gets the chance to do whatever operation is required before the system is allowed to suspend itself again, if nedd be.</p>
<h4 id="日志系统-Logger"><a href="#日志系统-Logger" class="headerlink" title="日志系统 Logger"></a>日志系统 Logger</h4><p>日志是目前包括嵌入式系统中，任何Linux系统上的必备组件。通过实时或出现问题后分析系统日志，可以在警告与错误中定位到致命问题所在，尤其是瞬间发生的错误。大部分Linux发行版都自带两套日志系统：通过<em>dmesg</em>命令访问的内核日志与以文件形式存储在<em>/var/log</em>路径下的系统日志。内核日志通常由各处<strong>printk()</strong>、核心内核代码或设备驱动调用输出。相对而言，系统日志包含的信息来自于运行在系统中各种守护进程与应用实时消息。实际上，你可以使用<em>logger</em>命令将自己的消息发送至系统日志中。<br>Logging is yet another essential component of any Linux system, embedded ones included. Being able to analyze a system’s logs for errors or warnings either in post-mortem or in real-time can be vital to isolate fatal errors, especially transient ones. By default, most Linux distributions include two logging systems: the kernel’s own log, typically accessed through the <em>dmesg</em> command, and the system logs, typically stored in files in the <em>/var/log</em> directory. The kernel’s log usually contains the messages printed out by the various <strong>printk()</strong> calls made within the kernel, either by core kernel code or by device drivers. For their part, the system logs contain messges coming from various daemons and utilities running in the system. In fact, you can use the <em>logger</em> command to send your own messages to the system log.</p>
<p>就安卓而言，日志的功能就是原样使用。然而，安卓的日志系统软件包无法在大多数Linux发行版中找到。相反，安卓定义了自己的日志机制，在内核中添加了安卓日志驱动。syslog依赖于通过套接字发送消息，并以此引出了任务开关。它还使用文件存储信息，这就涉及到存储设备的写操作。反之，安卓日志功能管理了一系列独立的内核缓冲区，用于记录来自用户空间的数据。因此，事件的记录无需任务切换或文件写入。相反，驱动维护的循环缓冲区能够记录记录每个事件并立即返回给调用方。<br>With regard to Android, the kernel’s logging functionality is used as-is. However, none of the usual system logging software packages typeically found in most Linux distributions is found in Android. Instead, Android defines its own logging mechanisms based on the Android logger driver added to the kernel. syslog relies on sending messages through sockets, and therefore generates a  task switch. It also uses files to store its information, therefore generating writes to a storage device. In contrast, Android’s logging functionality manages a handful of separate kernel-hosted buffers for logging data coming from user-space. Hence, no task-switches or file writes are required for each event being logged. Instead, the driver maintains circular buffers where it logs every incoming event and returns immediately back to the caller.</p>
<p>正因为其轻量而高效的设计，安卓日志才能真正在运行时以用户空间组件规律地记录事件。实际上，对应用开发者开放<strong>Log</strong>类，或多或少直接授权了日志驱动写入主事件缓存。显然，所有的好东西都会被滥用，最好能够保持日志框架轻量。但是综合考虑应用程序API公开<strong>Log</strong>，以及AOSP本身对日志的使用，如果基于syslog则很难维持这样的使用级别。<br>Because of its light-weight and efficient design, Android’s logger can actually be used by user-space components at run-time to regularly log events. In fact, the <strong>Log</strong> class available to app developers more or less directly invokes the logger driver to write to the main event buffer. Obviously, all good things can be abused and it’s preferable to keep the logging light, but still the level of use made possible by exposing <strong>Log</strong> through the app API along with the level of use of logging within the AOSP itself would have likely been very difficult to sustain had Android’s logging been based on syslog.</p>
<p>图2-2描述了安卓日志框架的细节。如图所示，日志驱动是所有日志相关功能得以运行的基础核心模块。在<em>/dev/log/</em>目录下各个缓冲区作为单独的条目。然而，没有用户空间组件直接与驱动交互。相反，他们都依赖liblog提供一系列不同的日志功能。根据功能使用与传递的参数，事件会记录到不同的缓存中。<strong>Log</strong>和<strong>Slog</strong>类使用liblog库，例如首先检测事件是否来自音频相关模块，如果是，则事件被分发至音频缓存区。否则，<strong>Log</strong>类会将事件传给“主”缓冲区，此时<strong>Slog</strong>类再将事件给“系统”缓冲区。主缓冲区事件在没有任何参数的情况下会在<em>logcat</em>命令中显示。<br>Figure 2-2 describes Android’s logging framework in more detail. As you can see, the logger driver is the core building block on which all other logging-related functionality relies. Each buffer it manages is exposed as a separate entry within <em>/dev/log/</em>. However, no user-space component directly interacts with that driver. Instead, they all rely on liblog which provides a number of different logging functions. Depending on the functions being used and the parameters being passed, events will get logged to different buffers. The liblog functions used by the <strong>Log</strong> and <strong>Slog</strong> classes, for instance, will test whether the event being dispatched comes from a radio-related module. If so, the event is sent to the “radio” buffer. If not, the <strong>Log</strong> class will send the event to the “main” buffer where the <strong>Slog</strong> class will send it to the “system” buffer. The “main” buffer is one whose events are shown by the <em>logcat</em> command when it’s issued without any parameters.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2424151-3162cfa959ce7c50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 2-2. Android&#39;s logging framework"></p>
<p><strong>Log</strong>和<strong>EventLog</strong>类都可以通过应用的API调用，但<strong>Slog</strong>只能由AOSP内部使用。尽管<strong>EventLog</strong>开放给了应用开发人员，但文档中明确说明了其主要开放给系统集成商而非应用开发者。事实上，绝大部分开发代码样例中都使用了<strong>Log</strong>类。通常，<strong>EventLog</strong>是系统组件使用，尤其是系统服务器主机？类服务将结合<strong>Log</strong>，<strong>Slog</strong>和<strong>EventLog</strong>来记录各类事件。与应用开发人员相关的日志可能使用<strong>Log</strong>，而与平台集成相关的日志就可能使用<strong>Slog</strong>或<strong>EventLog</strong>。<br>Both the <strong>Log</strong> and <strong>EventLog</strong> classes are exposed through the app development API, while <strong>Slog</strong> is for internal AOSP use only. Despite being available to app developers, though, <strong>EventLog</strong> is clearly identified in the documentation as mainly or system integrators, not app developers. In fact, the vast majority of code samples and examples provided as part of the developer documentation use the <strong>Log</strong> class. Typically, <strong>EventLog</strong> is used by system components, especially System Server-hosted services, will use a combination of <strong>Log</strong>, <strong>Slog</strong>, and <strong>EventLog</strong> to log different events. An event that might be relevant to  app developers, for instance, might be logged using <strong>Log</strong>, while an event relevant to platform developers or system integrators might be logged using either <strong>Slog</strong> or <strong>EventLog</strong>.</p>
<p>要注意的是，<strong>logcat</strong>这样的实用工具也依赖于liblog。除了添加访问日志驱动的接口，liblog还提供了美化打印与过滤器格式化事件功能。另一个特性是，liblog要求每一个事件需要标明优先级、标签与数据。优先级可以选择<strong>verbose</strong>，<strong>debug</strong>，<strong>info</strong>，<strong>warn</strong>或<strong>error</strong>。标签是一个唯一的字符串用于区分日志属于不同的模块或组件。数据就是需要被记录的具体信息。<br>Note that the <strong>logcat</strong> utility, which is commonly used by app developers to dump the Android logs, also relies on liblog. In addition to providing access functions to the logger driver, liblog also provides functionality for formatting events for pretty printing and filtering. Another feature of liblog is that it requires every envent being logged to have a priority, a tag, and data. The priority is one of <strong>verbose</strong>, <strong>debug</strong>, <strong>info</strong>, <strong>warn</strong>, or <strong>error</strong>. The tag is a unique string that identifies the component or module writing to the log, and the data is the actual information that needs to be logged. This description should in fact sound fairly familiar to anyone exposed to the app development API, as this is exactly what’s spelled out by the developer documentation for the <strong>Log</strong> class.</p>
<p>The final piece of the puzzle here is the <em>adb</em> command. As we’ll discuss later, the AOSP includes an Android Debug Bridge (ADB) daemon that runs on the Android device and that is accessed from the host using the <em>adb</em> command-line tool. When you type <em>adb logcat</em> on the host, the daemon actually launchers the <em>logcat</em> command locally on the target to dump its “main” buffer and then transfers that back to the host to be shown on the terminal.</p>
<h4 id="其他值得一提的安卓主义-Other-Notable-Androidisms"><a href="#其他值得一提的安卓主义-Other-Notable-Androidisms" class="headerlink" title="其他值得一提的安卓主义 Other Notable Androidisms"></a>其他值得一提的安卓主义 Other Notable Androidisms</h4>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Embedded-Android-Translation/" rel="tag"># Embedded Android Translation</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/05/我能吞下玻璃而不伤身体/" rel="next" title="我能吞下玻璃而不伤身体">
                <i class="fa fa-chevron-left"></i> 我能吞下玻璃而不伤身体
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/15/CODE39编码/" rel="prev" title="CODE39编码">
                CODE39编码 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/pk.png"
                alt="Ross Zeng" />
            
              <p class="site-author-name" itemprop="name">Ross Zeng</p>
              <p class="site-description motion-element" itemprop="description">那就这样吧</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/zengrx" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://gitee.com/rx_z" target="_blank" title="OSChina">
                    
                      <i class="fa fa-fw fa-globe"></i>OSChina</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://steamcommunity.com/id/zengrx/" target="_blank" title="Steam">
                    
                      <i class="fa fa-fw fa-steam"></i>Steam</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.instagram.com/zeng_rx/" target="_blank" title="Instagram">
                    
                      <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://yarrow1995.github.io/" title="Madoka酱" target="_blank">Madoka酱</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#内部入门-Internals-Primer"><span class="nav-number">1.</span> <span class="nav-text"><a href="#&#x5185;&#x90E8;&#x5165;&#x95E8;-Internals-Primer" class="headerlink" title="&#x5185;&#x90E8;&#x5165;&#x95E8; Internals Primer"></a>&#x5185;&#x90E8;&#x5165;&#x95E8; Internals Primer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用开发人员的看法-App-Developer’s-View"><span class="nav-number">2.</span> <span class="nav-text"><a href="#&#x5E94;&#x7528;&#x5F00;&#x53D1;&#x4EBA;&#x5458;&#x7684;&#x770B;&#x6CD5;-App-Developer&#x2019;s-View" class="headerlink" title="&#x5E94;&#x7528;&#x5F00;&#x53D1;&#x4EBA;&#x5458;&#x7684;&#x770B;&#x6CD5; App Developer&#x2019;s View"></a>&#x5E94;&#x7528;&#x5F00;&#x53D1;&#x4EBA;&#x5458;&#x7684;&#x770B;&#x6CD5; App Developer&#x2019;s View</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安卓概念-Android-Concepts"><span class="nav-number">2.1.</span> <span class="nav-text"><a href="#&#x5B89;&#x5353;&#x6982;&#x5FF5;-Android-Concepts" class="headerlink" title="&#x5B89;&#x5353;&#x6982;&#x5FF5; Android Concepts"></a>&#x5B89;&#x5353;&#x6982;&#x5FF5; Android Concepts</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#组件-components"><span class="nav-number">2.1.1.</span> <span class="nav-text"><a href="#&#x7EC4;&#x4EF6;-components" class="headerlink" title="&#x7EC4;&#x4EF6; components"></a>&#x7EC4;&#x4EF6; components</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#意图-Intents"><span class="nav-number">2.1.2.</span> <span class="nav-text"><a href="#&#x610F;&#x56FE;-Intents" class="headerlink" title="&#x610F;&#x56FE; Intents"></a>&#x610F;&#x56FE; Intents</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#组件的生命周期-Component-Lifecycle"><span class="nav-number">2.1.3.</span> <span class="nav-text"><a href="#&#x7EC4;&#x4EF6;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;-Component-Lifecycle" class="headerlink" title="&#x7EC4;&#x4EF6;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F; Component Lifecycle"></a>&#x7EC4;&#x4EF6;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F; Component Lifecycle</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Manifest文件-Manifest-File"><span class="nav-number">2.1.4.</span> <span class="nav-text"><a href="#Manifest&#x6587;&#x4EF6;-Manifest-File" class="headerlink" title="Manifest&#x6587;&#x4EF6; Manifest File"></a>Manifest&#x6587;&#x4EF6; Manifest File</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程与线程-Processses-and-Threads"><span class="nav-number">2.1.5.</span> <span class="nav-text"><a href="#&#x8FDB;&#x7A0B;&#x4E0E;&#x7EBF;&#x7A0B;-Processses-and-Threads" class="headerlink" title="&#x8FDB;&#x7A0B;&#x4E0E;&#x7EBF;&#x7A0B; Processses and Threads"></a>&#x8FDB;&#x7A0B;&#x4E0E;&#x7EBF;&#x7A0B; Processses and Threads</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#远程过程调用（RPC）-Remote-Proceduce-Calls-RPC"><span class="nav-number">2.1.6.</span> <span class="nav-text"><a href="#&#x8FDC;&#x7A0B;&#x8FC7;&#x7A0B;&#x8C03;&#x7528;&#xFF08;RPC&#xFF09;-Remote-Proceduce-Calls-RPC" class="headerlink" title="&#x8FDC;&#x7A0B;&#x8FC7;&#x7A0B;&#x8C03;&#x7528;&#xFF08;RPC&#xFF09; Remote Proceduce Calls (RPC)"></a>&#x8FDC;&#x7A0B;&#x8FC7;&#x7A0B;&#x8C03;&#x7528;&#xFF08;RPC&#xFF09; Remote Proceduce Calls (RPC)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#框架介绍-Framework-Intro"><span class="nav-number">2.2.</span> <span class="nav-text"><a href="#&#x6846;&#x67B6;&#x4ECB;&#x7ECD;-Framework-Intro" class="headerlink" title="&#x6846;&#x67B6;&#x4ECB;&#x7ECD; Framework Intro"></a>&#x6846;&#x67B6;&#x4ECB;&#x7ECD; Framework Intro</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用开发工具-App-Development-Tools"><span class="nav-number">2.3.</span> <span class="nav-text"><a href="#&#x5E94;&#x7528;&#x5F00;&#x53D1;&#x5DE5;&#x5177;-App-Development-Tools" class="headerlink" title="&#x5E94;&#x7528;&#x5F00;&#x53D1;&#x5DE5;&#x5177; App Development Tools"></a>&#x5E94;&#x7528;&#x5F00;&#x53D1;&#x5DE5;&#x5177; App Development Tools</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原生开发-Native-Development"><span class="nav-number">2.4.</span> <span class="nav-text"><a href="#&#x539F;&#x751F;&#x5F00;&#x53D1;-Native-Development" class="headerlink" title="&#x539F;&#x751F;&#x5F00;&#x53D1; Native Development"></a>&#x539F;&#x751F;&#x5F00;&#x53D1; Native Development</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总体结构-Overall-Architecture"><span class="nav-number">3.</span> <span class="nav-text"><a href="#&#x603B;&#x4F53;&#x7ED3;&#x6784;-Overall-Architecture" class="headerlink" title="&#x603B;&#x4F53;&#x7ED3;&#x6784; Overall Architecture"></a>&#x603B;&#x4F53;&#x7ED3;&#x6784; Overall Architecture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux内核-Linux-Kernel"><span class="nav-number">4.</span> <span class="nav-text"><a href="#Linux&#x5185;&#x6838;-Linux-Kernel" class="headerlink" title="Linux&#x5185;&#x6838; Linux Kernel"></a>Linux&#x5185;&#x6838; Linux Kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Wakelocks-唤醒锁"><span class="nav-number">4.1.</span> <span class="nav-text"><a href="#Wakelocks-&#x5524;&#x9192;&#x9501;" class="headerlink" title="Wakelocks &#x5524;&#x9192;&#x9501;"></a>Wakelocks &#x5524;&#x9192;&#x9501;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Low-Memeory-Killer-低内存杀手"><span class="nav-number">4.2.</span> <span class="nav-text"><a href="#Low-Memeory-Killer-&#x4F4E;&#x5185;&#x5B58;&#x6740;&#x624B;" class="headerlink" title="Low Memeory Killer &#x4F4E;&#x5185;&#x5B58;&#x6740;&#x624B;"></a>Low Memeory Killer &#x4F4E;&#x5185;&#x5B58;&#x6740;&#x624B;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binder-Binder"><span class="nav-number">4.3.</span> <span class="nav-text"><a href="#Binder-Binder" class="headerlink" title="Binder Binder"></a>Binder Binder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匿名共享内存-Anonymous-Share-Memory-ashmem"><span class="nav-number">4.4.</span> <span class="nav-text"><a href="#&#x533F;&#x540D;&#x5171;&#x4EAB;&#x5185;&#x5B58;-Anonymous-Share-Memory-ashmem" class="headerlink" title="&#x533F;&#x540D;&#x5171;&#x4EAB;&#x5185;&#x5B58; Anonymous Share Memory (ashmem)"></a>&#x533F;&#x540D;&#x5171;&#x4EAB;&#x5185;&#x5B58; Anonymous Share Memory (ashmem)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闹钟-Alarm"><span class="nav-number">4.5.</span> <span class="nav-text"><a href="#&#x95F9;&#x949F;-Alarm" class="headerlink" title="&#x95F9;&#x949F; Alarm"></a>&#x95F9;&#x949F; Alarm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日志系统-Logger"><span class="nav-number">4.6.</span> <span class="nav-text"><a href="#&#x65E5;&#x5FD7;&#x7CFB;&#x7EDF;-Logger" class="headerlink" title="&#x65E5;&#x5FD7;&#x7CFB;&#x7EDF; Logger"></a>&#x65E5;&#x5FD7;&#x7CFB;&#x7EDF; Logger</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他值得一提的安卓主义-Other-Notable-Androidisms"><span class="nav-number">4.7.</span> <span class="nav-text"><a href="#&#x5176;&#x4ED6;&#x503C;&#x5F97;&#x4E00;&#x63D0;&#x7684;&#x5B89;&#x5353;&#x4E3B;&#x4E49;-Other-Notable-Androidisms" class="headerlink" title="&#x5176;&#x4ED6;&#x503C;&#x5F97;&#x4E00;&#x63D0;&#x7684;&#x5B89;&#x5353;&#x4E3B;&#x4E49; Other Notable Androidisms"></a>&#x5176;&#x4ED6;&#x503C;&#x5F97;&#x4E00;&#x63D0;&#x7684;&#x5B89;&#x5353;&#x4E3B;&#x4E49; Other Notable Androidisms</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ross Zeng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
