---
title: 公钥密码学-RSA
date: 2021-06-13 13:43:56
tags:
- cryptography
- math
- RSA
---

多年以后，面对ssl中奔流不息的数据时，我可能仍会想起在11教第一次听董荣胜说起非对称加密的那个飘着桂花味的下午。那时五教和B区之间的荒地才被烧过没多久，围墙还没拆，综合楼和新足球场也没建起来。我还是一个会认真到在图书馆找资料手算反码和补码的大一新生，下课后带着一个手抓饼回宿舍做了几道以3 7 9 11之类的小素数计算验证RSA加解密过程的课后练习，一切都很新鲜，一切似乎才刚刚开始。

<!--more-->

### 概述

公钥密码学的复习其实酝酿了很久，抛开椭圆曲线先不论，基于数论的RSA设计原理让一个中学生去学习应该也问题不大。但是近来感觉思维没有那么灵活，做欧拉函数和中国剩余定理证明时总觉得脑子转的不够快，而且中途也老被七七八八的杂事打断，导致有些过程不停地卡关，到现在磕磕绊绊大体完成。最初计划公钥密码学是按照课本的目录顺序，先从数论基础和抽象代数开始切入，但是想了想当初自己就是这么学的，效果似乎没那么好，而且学习方法因人而异，没有什么万能的套路。总之我还是决定直接把内容拆成RSA和ECC两个部分，顺着算法设计的视角看待涉及到的数学本质问题。

公钥密码学的发展可以被称为密码学出现以来最伟大的一次革命，甚至是唯一一次革命。在这之前，几乎所有的密码体制都是基于代替与置换来设计的，即使DES，AES这类密码系统也都是在初等方法之上尽可能地消除明文的分布特征。而公钥密码体制则是找出了一个单向函数（注意并不是单向hash函数，是one-way trap door function），在没有一些特定的附加信息情况下做逆运算是时间上不可行的事情，而拥有了这些附加信息就可以在多项式时间内计算出函数的逆。其实这里已经足够说明公钥密码与传统密码的本质区别：公钥算法是基于数学函数而非代替和置换。在Diffie和Hellman提出的设计概念中，拥有两个独立密钥的公钥密码体制能够解决对称密码秘密钥分配问题与数字签名问题。在这里也顺便澄清几个概念：
+ 公钥密码不一定比传统密码安全。可以说任何加密方法的安全性都需要依赖密钥长度和破译密文的时间成本，在算力暴增的如今，RSA能做的事情也只是声明512 bits的密钥已经不够安全，应全面停止使用。甚至可以想象当量子计算商用化那天来到时，现有的密码体系都要面临大灾难，想要达到与传统计算相同的安全性，所需的密钥长度就要以量子比特存储器单元的个数呈指数膨胀。
+ 公钥密码不是用来取代传统密码。公钥密码更多的是与传统密码相结合，进而完善加密体系。“公钥密码仅限于用在密钥管理和签名这类应用中，这几乎是已被广泛接收的事实。”
+ 公钥密码不是独自完成密钥分配。并不是说公钥密码学诞生后就立刻轻松地解决了对称密码的分配的问题，它也需要通过一系列政策、服务平台、软件策略等来管理证书与密钥对，也就是CA中心及所部署的PKI系统。
+ 还有诸如“公钥只能加密不能解密，私钥只能解密不能加密”，“公钥不能算出私钥但私钥可以算出公钥”等等这些无聊的争论我实在是不想解释，希望大家不要钻牛角尖，多学习，多实践，少bb。

文章将以[RIVE78]()为理论基础，介绍公钥密码学中最早提出且成功的RSA算法设计概论，以及算法中涉及到的数学运算原理。~~之后结合密钥及证书文件来看PKCS制定的编码标准。~~

### 公钥密码体系与RSA

在Diffie和Hellman于1976年发表的*New directions in cryptography*一文中其实已经给出了指导思想，设计的四个特性如下：
对于加密过程E，解密过程D，有消息M
a. 解密一个被加密的消息，可以表达为： D(E(M)) = M 。
b. 过程E和过程D都很容易计算。
c. 被公开的过程E不能够公开过程D的快速运算方法。只有加密者本人才能够解密被加密的信息，或快速运算过程D。
d. 如果消息M先解密再加密，仍然会得到M，表达为： E(D(M)) = M 。

对于满足a b c三个特性的方法被称为单向陷门函数（trap-door on-way function）；如果同时满足特性d，则被称为单向陷门置换（trap-door on-way permutation）。一般来说只有在设计数字签名算法的时候才需要额外满足特性d。RSA的设计遵循了单向陷门置换，算法本质是大素数分解的计算困难性。

### RSA与数论基础

在聊RSA之前先说说古典密码中的代替技术，例如最典型的凯撒密码。我一直将这类密码近似地理解为一次函数，即f(x)=kx+b。对于这样的加密，很容易通过穷举还原x：设m=f(x), x=$\frac{m-b}{k}$。如此一来最大程度将具象的加密操作抽象成数学符号语言，再回过头看RSA的天才设计。

RSA巧妙地借助了模运算来还原明文，并通过幂运算隐藏参与通信双方的秘密。顺着算法思路，可以得到如下设计:
f(x) mod n = x，f(x)=x<sup>a</sup>，其中a包含两个密钥相关的内容。

#### 费马小定理

#### 欧拉函数

### 计算优化

#### 中国剩余定理的特殊场景

### 一些问题

### 参考文献

### 附录

#### APPENDIX A 证明过程

#### APPENDIX B 基于小素数的计算
