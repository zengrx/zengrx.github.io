---
title: 公钥密码学-RSA
date: 2021-06-13 13:43:56
tags:
- cryptography
- math
- RSA
---

多年以后，面对ssl中奔流不息的数据时，我可能仍会想起在11教第一次听董荣胜说起非对称加密的那个飘着桂花味的下午。那时五教和B区之间的荒地才被烧过没多久，围墙还没拆，综合楼和新足球场也没建起来。我还是一个会认真到在图书馆找资料手算反码和补码的大一新生，下课后带着一个手抓饼回宿舍做了几道以3 7 9 11之类的小素数计算验证RSA加解密过程的课后练习，一切都很新鲜，一切似乎才刚刚开始。

<!--more-->

### 开始新的旅途

公钥密码学的复习其实酝酿了很久，抛开椭圆曲线先不论，基于数论的RSA设计原理让一个中学生去学习应该也问题不大。但是近来感觉思维没有那么灵活，做欧拉函数和中国剩余定理证明时总觉得脑子转的不够快，而且中途也老被七七八八的杂事打断，导致有些过程不停地卡关，到现在磕磕绊绊大体完成。最初计划公钥密码学是按照课本的目录顺序，先从数论基础和抽象代数开始切入，但是想了想当初自己就是这么学的，效果似乎没那么好，而且学习方法因人而异，没有什么万能的套路。总之我还是决定直接把内容拆成RSA和ECC两个部分，顺着算法设计的视角看待涉及到的数学本质问题。

公钥密码学的发展可以被称为密码学出现以来最伟大的一次革命，甚至是唯一一次革命。在这之前，几乎所有的密码体制都是基于代替与置换来设计的，即使DES，AES这类密码系统也都是在初等方法之上尽可能地消除明文的分布特征。而公钥密码体制则是找出了一个单向函数（注意并不是单向hash函数，是one-way trap door function），在没有一些特定的附加信息情况下做逆运算是时间上不可行的事情，而拥有了这些附加信息就可以在多项式时间内计算出函数的逆。其实这里已经足够说明公钥密码与传统密码的本质区别：公钥算法是基于数学函数而非代替和置换。在Diffie和Hellman提出的设计概念中，拥有两个独立密钥的公钥密码体制能够解决对称密码秘密钥分配问题与数字签名问题。在这里也顺便澄清几个概念：
+ 公钥密码不一定比传统密码安全。可以说任何加密方法的安全性都需要依赖密钥长度和破译密文的时间成本，在算力暴增的如今，RSA能做的事情也只是声明512 bits的密钥已经不够安全，应全面停止使用。甚至可以想象当量子计算商用化那天来到时，现有的密码体系都要面临大灾难，想要达到与传统计算相同的安全性，所需的密钥长度就要以量子比特存储器单元的个数呈指数膨胀。
+ 公钥密码不是用来取代传统密码。公钥密码更多的是与传统密码相结合，进而完善加密体系。“公钥密码仅限于用在密钥管理和签名这类应用中，这几乎是已被广泛接收的事实。”
+ 公钥密码不是独自完成密钥分配。并不是说公钥密码学诞生后就立刻轻松地解决了对称密码的分配的问题，它也需要通过一系列政策、服务平台、软件策略等来管理证书与密钥对，也就是CA中心及所部署的PKI系统。但公钥密码体系确实使密钥管理更加容易。
+ 还有诸如“公钥只能加密不能解密，私钥只能解密不能加密”，“公钥不能算出私钥但私钥可以算出公钥”等等这些无聊的争论我实在是不想解释，希望大家不要钻牛角尖，多学习，多实践，少bb。

文章将以[RIVE78](https://people.csail.mit.edu/rivest/Rsapaper.pdf)为理论基础，介绍公钥密码学中最早提出且成功的RSA算法设计概论，以及算法中涉及到的数学运算原理。随后结合密钥及证书文件来看PKCS制定的编码标准，如何通过著名的openssl工具解析RSA密钥和证书，如何在c/c++中使用openssl提供的接口进行编程。

### 公钥密码体系与一点题外话

单纯说对明文进行加密，二战后发明的DES、AES这类现代对称密码完全够用，但是在使用对称密码时有一个根本问题：发送方和接收方必须预先共享一个密钥（secret key 秘密钥）。就算费点劲，整点魔法，双方通过托梦、心灵感应、灵魂交换等等手段分享好了密钥，也不可能一直只和某个特定的对象会话，那么涉及到多方的密钥管理会带来很夸张的工作量。例如在一个拥有100人的网络中，总共需要存在4950把不同的密钥（99+98+97+...+2+1=5050-100）才能保证两两之间通信可靠。

公钥密码体系在设计之初可能更多是为了解决这类通信密钥的管理问题，在1980年代美国海军舰队需要使用叉车来装卸船只之间的通信密钥记录文件，因为eve这个拥有执着这一美好品质的反派角色会锲而不舍地无所不用其极获取alice与bob之间会话密钥，所以用于保护明文消息的对称密钥需要频繁地更换。更不用说到互联网时代更为庞大的通信需求，这种形式的密钥管理那完全没法用，非常阻碍社会发展。

在Diffie和Hellman于1976年发表的*New directions in cryptography*一文中其实已经给出了指导思想，设计的四个特性如下：
对于加密过程E，解密过程D，有消息M
+ a. 解密一个被加密的消息，可以表达为： D(E(M)) = M 。
+ b. 过程E和过程D都很容易计算。
+ c. 被公开的过程E不能够公开过程D的快速运算方法。只有加密者本人才能够解密被加密的信息，或快速运算过程D。
+ d. 如果消息M先解密再加密，仍然会得到M，表达为： E(D(M)) = M 。

对于满足a b c三个特性的方法被称为单向陷门函数（trap-door on-way function）；如果同时满足特性d，则被称为单向陷门置换（trap-door on-way permutation）。一般来说只有在设计数字签名算法的时候才需要额外满足特性d。如果找到了这样一种全新的密码体系，那么参与通信的一方只需要将自己的过程E发布，一旦有会话请求，请求方会寻找这个公开的过程E处理信息发给对应的接收方。接收方使用只有自己知道的过程D即可还原得到请求方发送的原文信息。同样在一个100人的网络中，只需要100个过程E（当然每个过程E都有一个对应的过程D，在RSA中是modular multiplicative inverse 模乘法逆元）就可满足两两之间的通信保障要求。当然当然，可爱又迷人的反派角色eve仍然有办法做一些攻击，比如中间人、共模、低指数CRT分解等。所以实际应用中还有PKI，PKCS这类设施及标准来完善整个密码应用体系。

除了最基本的传递秘密消息之外，更进一步，单向陷门置换有个更加令人激动的应用场景就是数字签名。正如签名的含义，通过个人独特的笔迹来判断信息是否来源于对应的发送方。如果说加密保证了数据的保密性，那么数字签名就提供了不可篡改性与不可抵赖性。即一方将消息使用仅自己知道的过程D处理后公布，其余所有人都能用公开的过程E还原出原始消息，并且这个消息一定是由过程E所属的发送方发出。实际使用中一般是公布方对消息的摘要值做签名，随着消息明文一并公布；接收方经过程E处理得到摘要值，并使用同样的摘要算法对消息明文计算，对比两边的结果判断这份信息是否可靠。

最后在具体聊RSA之前我想插一个关于密码的思考，例如古典密码中的代替技术最典型代表凯撒密码。当然这并不一定值得推广，只是提一下我自己脑海中的一个概念。我一直倾向将这类密码近似地理解为一次函数，即$f(x)=kx+b$。对于这类单调的加密过程，很容易通过已知明文还原$x$：令$m=f(x)$, 有$x=\frac{m-b}{k}$。更进一步说，古典密码追求的极致是无限接近$f(x)=b$且有办法还原$x$，消除代替中遗留的语义统计特征，当然不同的语言系统中使用的文字符号及其组合方式会直接影响密码体系中信息熵的变化，这又是另一个话题。但还是要强调这只是我自己的一个直觉性思考方式，将具象的加密操作抽象成为符号语言，或者转化成几何的角度来看待问题，称不上准确。

### RSA与数论基础

RSA的设计遵循了单向陷门置换，算法本质是大素数分解的计算困难性。并巧妙地借助了模运算来还原明文，通过幂运算隐藏参与通信双方的秘密。虽然不知道Diffile和Hellman是怎么想到了构造幂模运算(RSA paper中的 "The aforementioned method should not be confused with the “exponentiation” technique presented by Diffie and Hellman [1] to solve the key distribution problem")，但我猜同余是个很抓眼球的特性，结合费马小定理看底数和模余数在特定条件下有机会相等，很值得用在这种密码体系的解密中。总之顺着算法思路，可以考虑如下设计:
$f(x) \; mod \; n = x，f(x)=x^a$，令其中a包含两个密钥相关的内容{e, d}，得到计算式 $(M^e \; mod \; n)^d \; mod \; n = M$
到这里已经有一个隐约的概念，将消息M做幂运算后取模，就算余数和模数被公开也无法得知原消息M，而参与运算的指数{e, d}经过了精心挑选，能够使用余数的幂做模运算还原消息M。这个过程的正确性就由数论中的几个经典问题支撑。

之前和朋友们瞎比聊过这帮数学怪们到底怎么发明出这些诡异的算法，大致结论是最终呈现在大家眼前的已经是精华中的精华，他们需要深刻地掌握和运用足够多的基础理论知识来形成对应问题的体系框架，通过经验也好，灵感也罢，甚至远在星辰之外的一丝运气，才在无尽的数学花园中采到了一些看起来合适的原料，不断加工组合验证推导，花费数年、数十年，甚至终其一生扑在一个问题中。没有写下Q.E.D之前四周都是迷雾。我们学习这些理论时，所有正确的原料早已明确，重复一个过程谈不上困难，尽量在经历这个过程中领悟一些东西吧。

一般教材会计划提前一章学习一些数论知识，有的学校在给信息安全专业制定培养计划时会专门安排专业数学基础课程。其实最初我的打算是写公式时加入相关定理的证明过程，以此来充实整个理论推导过程，但是写着写着发现太<sup>TM</sup>不流畅了，看公式体验真滴差。最后决定先只对RSA Paper稍微补充少量中间步骤，毕竟原论文也是真滴简洁，便于在一定数论基础上的理解。这篇文章并不是科普数论基础，但我认为也有的地方值得多说几句，就写在本章的证明之后。

<center>draft && paper</center>![math_draft_paper](https://ftp.bmp.ovh/imgs/2021/07/fa4e651545e73287.png)


那么来康康完成这个设计自己手上有多少牌可以打。

+ 费马小定理
    $$a^{p-1} \equiv 1 \pmod p \; , \; a是整数，p是素数$$
+ 欧拉定理
    $$a^{\phi(n)} \equiv 1 \pmod n \; , \; a与n互素$$
+ 中国剩余定理
    存在正整数r<sub>1</sub>, r<sub>2</sub>，有整数gcd(n<sub>1</sub>, n<sub>2</sub>)=1, 则同余方程组
    $$
    \begin{cases}
    x \equiv r_1 \pmod {n_1} & \\
    x \equiv r_2 \pmod {n_2} & \\
    \end{cases}
    $$
    x在[0, n<sub>1</sub>n<sub>2</sub>)内有唯一解。
+ 模运算及幂运算的一些计算性质

算法的安全基础在于素因数分解的计算困难性，那么至少需要存在两个素数，记为p与q，将p与q的乘积记为n。将消息记为M，用于指代M的数字取值范围为(0, n-1]。
$$n=p \cdot q$$
要利用同余，模数必然要公开，结合欧拉定理当M与n互素时，有$M^{\phi(n)} \equiv 1 \pmod n$，欧拉定理在RSA中起到了很重要的作用，不过现在离终点还很远，需要往里边加点料。在这里可以先猜想一个更理想的算式表达形式：$M^{\phi(n)+1} \equiv M \pmod n$。
$\phi(n)$是一个很关键的因素，有必要在附录中给出一些证明过程，这里先直接给结论。由于p和q选择了素数，则有
$$\phi(n) = \phi(p \cdot q) = \phi(p)\cdot\phi(q) = (p-1)(q-1)$$
回过头来看一眼想要的结果
$$(M^e \; mod \; n)^d \; mod \; n = M$$
如果用抽象代数的方式来表达会非常简洁，模映射是一种环同态，朴素点说呢，这是个这是个朴素的模运算分配律，幂运算可以表示连续的乘法运算，乘法运算可以表示连续的加法运算，所以there's a modular exponentiation property：
$$a^b \; mod \; c = (a \; mod \; c)^b \; mod \; c$$
于是可以把目标式可以写作
$$(M^e \; mod \; n)^d \; mod \; n = M^{ed} \; mod \; n$$
这个转换带来了$e$和$d$的乘积表达。且算法的终极目标是论证下式成立
$$M^{ed} \equiv M \pmod n$$
现在手握 $M^{\phi(n)} \equiv 1 \pmod n$ 与 $M^{ed} \; mod \; n$，可以考虑通过1来把 $ed$ 和 $\phi(n)$ 连上线。接下来是一个很关键的设计：随机挑选一个小于$\phi(n)$的大整数$d$，使$d$与$\phi(n)$互素，即
$$gcd(d, \phi(n)) = 1$$
有了这个就可以保证一定存在模乘法逆元，即一定存在$e$，使得
$$ed \equiv 1 \pmod {\phi(n)}$$
结合同余的性质，必定存在$k, k\in \mathbb{Z}$，使得$ed = k \phi(n) + 1$。这个时候不要再往欧拉定理里钻了，再钻就快到死胡同了，换个角度请出费马小定理和中国剩余定理。来看$M^{ed} \; mod \; p$ 与 $M^{ed} \; mod \; q$
$$\because ed = k \phi(n) + 1 \therefore M^{ed} = M^{k \phi(n) + 1} = M^{k(p-1)(q-1) + 1} = M \cdot (M^{(p-1)})^{k(q-1)}$$
模数是素数，M可为任意正整数。带入$M^{p-1} \equiv 1 \pmod p$，得到了
$$M^{ed} \equiv M^{k \phi(n) + 1} \equiv M \cdot 1^{k(q-1)} \equiv M \pmod p$$
同理对于q而言，相似的因为$M^{q-1} \equiv 1 \pmod q$，则
$$M^{ed} \equiv M^{k \phi(n) + 1} \equiv M \cdot 1^{k(p-1)} \equiv M \pmod q$$
因为n是p和q的乘积，必然有
$$M^{ed} \equiv M^{k \phi(n) + 1} \equiv M \pmod n$$
得到结论：对于任意$M, \; 0 \leq M < n$，过程$E$与过程$D$是逆置换。

根据以上论证，RSA算法密钥对产生过程为
>1. $选择两个大素数p与q，计算出乘积n = p \cdot q，其中n作为模数是公开的，p与q是保密的$
2. $计算欧拉函数\phi(n)=(p-1)(q-1)$
3. $寻找一个大整数d与\phi(n)互素，并计算d模\phi(n)的乘法逆元e，使得ed \equiv 1 \pmod {\phi(n)}$
4. $元素\lbrace e, n \rbrace作为公钥可以公开发布，元素\lbrace d, n\rbrace作为私钥由产生者保管$

传递消息的保密性
>1. $会话请求方需要传递消息M，计算C = M^e \; mod \; n，将C发送给接收方$
2. $接收方用自己的私钥解密C，计算M = C^d \; mod \; n$

数字签名与验签
>1. $消息发布方需求公开消息M，计算S = M^d \; mod \; n，将签名S公开$
2. $获取方用公钥对签名S验证，计算M = S^e \; mod \; n$


**以下是对一些“易得，显然，不难证明，由上可知”的补充。**
对于模运算的分配率换个有意思的说法：女术士打桩机杰洛特每次需要用3个弱效突变诱发物合成1个突变诱发物，杰洛特有a个弱效突变诱发物，一波操作之后合成几次忘记了，总之还剩下1个弱效突变诱发物；跑图打了一圈孽鬼沼泽巫婆腐食魔之后又得到了b个弱效突变诱发物，又操作一波合成突变诱发物，最后刚好一个弱效突变诱发物都不剩。这和先有a个弱效突变诱发物再打b个弱效突变诱发物攒在一起合成突变诱发物没有区别。公式一下就是$(a \; mod \; c + b) \; mod \; c = (a + b) \; mod \; c$。多次重复这个过程就是乘法的模运算。而用3个突变诱发物合成1个强效突变诱发物，从弱效突变诱发物的角度看就是幂模。

当我们看到形如$a \equiv b \pmod n$，需要理解$a$与$b$的绝对值是$n$的倍数，即a b之间形成了模运算下的相等，该式完整表达为$a \; mod \; n =  b \; mod \; n$，千万不要理解成$a \; mod \; n =  b$。在没有特别指明时，$a \; b \; n$ 之间应该是没有具体的大小关系，当然如果$a$和$b$都是正整数且都小于$n$，那么$a$与$b$数值相等。

RSA中用来指代明文消息的M是一个取值范围在0到n的正整数，这是中国剩余定理中提到的唯一解（特解）。中国剩余定理本质上是在求一元线性同余方程组的通解。通俗地说，给出互素的两个数p和q，p q的乘积n，对于正整数a小于n，a可以由a除以p的余数和a除以q的余数唯一确定。加密的消息要能够正确地被还原出来，就需要加以这个范围的限制，否则就只能得到通解。

结合幂模运算，$ed \equiv 1 \pmod {\phi(n)}$是一个关键设计。如果算法满足单向陷门函数，就需要设计某个方法及其对应的逆方法。而满足单向陷门置换，相当于这个逆方法不能对参数的顺序做要求。RSA中选择以乘法的形式来构造D方法和E方法，而通过乘法逆元又可以将除法这个不可靠的逆运算转化为乘法运算，modular mutiplicative inverse满足了单向陷门置换的方法统一。保证乘法逆元有且唯一，则需满足$gcd(d, \phi(n)) = 1$，这个d就需要生成密钥对时去构造。

对于$M^{ed} \equiv M \pmod p,  M^{ed} \equiv M \pmod q \Longrightarrow M^{ed} \equiv M \pmod n$，不妨这么来看：
令$a = M^{ed} - M$，上式表达的含义则可以转化为存在一个数a能够同时被p和q整除，那么a一定能被p和q的最小公倍数整除。而n是p和q最小公倍数与最大公约数的乘积，所以a一定能被n整除。既然推导了整除成立，在此基础上两边加相同的数显然同余成立。多说一句，单论推论成立p和q为正整数即可，模为素数是费马小定理的要求。但p和q互素是中国剩余定理中有且有唯一解的必要条件。

### 计算优化

#### e与d的选择
较于对称系统，非对称密码有一个尤其突出的特点是通信双方的计算内容不同，更进一步说，如RSA可以为加解密过程设计不同的计算量级。仔细看过RSA paper的话可以发现，当时作者们设计的方法是选择一个足够大的整数d（You then pick the integer d to be a large, random integer which is relatively prime to (p − 1) · (q − 1)），再计算乘法逆元e。而在实际使用中，往往是先选择一个小素数e，再计算d。从两个角度来看这个做法。首先，d是私钥的元素，所以必须保证d是一个很难被猜测的值，而e设计就是用来公开的，所以即使选择一个很小的e（但注意小素数可能会因低加密指数广播攻击带来明文泄露的风险）并不会破坏非对称系统整体的安全性，反倒让攻击者更难确定私钥d；另一点是使用小e可以减小加密（及验签）方的计算量，一般考虑服务器具备更强大的运算性能，所以会算你就多算点。

RSA也有很多攻击方法，毕竟保密性、可靠性、完整性、不可篡改性哪一个挂逼都不安全，安全等级也各有区别。这里借着公钥参数e单独说一说低加密指数广播攻击的场景。


#### 中国剩余定理的特殊场景

### Back to the real world

#### openssl命令

#### openssl接口

### 一些问题

### 参考文献

1. 密码编码学与网络安全（第五版）
2. [A Method for Obtaining Digital Signatures and Public-key Cryptosystems](https://people.csail.mit.edu/rivest/Rsapaper.pdf)
2. [New Directions in Cryptography](https://ee.stanford.edu/~hellman/publications/24.pdf)
2. [The science of encryption: prime numbers and mod n arithmetic](https://math.berkeley.edu/~kpmann/encryption.pdf)
2. [Number Theory - Euclid's Algorithm](https://crypto.stanford.edu/pbc/notes/numbertheory/euclid.html)
2. [Number Theory - Chinese Remainder Theorem](https://crypto.stanford.edu/pbc/notes/numbertheory/crt.html)
2. [Using the CRT with RSA](https://www.di-mgt.com.au/crt_rsa.html)
2. [跨越千年的RSA算法](http://www.matrix67.com/blog/archives/5100)
2. [Number Theory - Modular Exponentiation](https://crypto.stanford.edu/pbc/notes/numbertheory/exp.html)
3. [Does RSA work for any message m](https://crypto.stackexchange.com/questions/1004/does-rsa-work-for-any-message-m)
4. [Why is important to choose e coprime to $\phi(n)$](https://crypto.stackexchange.com/questions/12255/in-rsa-why-is-it-important-to-choose-e-so-that-it-is-coprime-to-%CF%86n)
5. 
6. 
7. 

### 附录

#### APPENDIX A 证明过程

#### APPENDIX B 基于小素数的计算
